package changeset

import (
	"reflect"
	"strconv"
	"strings"

	"github.com/Fs02/grimoire/errors"
)

// CastAssocErrorMessage is the default error message for CastAssoc.
var CastAssocErrorMessage = "{field} is invalid"

// ChangeFunc is changeset function.
type ChangeFunc func(interface{}, map[string]interface{}) *Changeset

// CastAssoc casts association changes using changeset function.
// Repo insert or update won't persist any changes generated by CastAssoc.
func CastAssoc(ch *Changeset, field string, fn ChangeFunc, opts ...Option) {
	options := Options{
		message: CastAssocErrorMessage,
	}
	options.apply(opts)

	par, pexist := ch.params[field]
	typ, texist := ch.types[field]
	valid := true

	if pexist && texist {
		if typ.Kind() == reflect.Struct {
			valid = castOne(ch, field, typ, par, fn)
		} else if typ.Kind() == reflect.Slice && typ.Elem().Kind() == reflect.Struct {
			valid = castMany(ch, field, typ, par, fn)
		}
	}

	if !valid {
		msg := strings.Replace(options.message, "{field}", field, 1)
		AddError(ch, field, msg)
	}
}

func castOne(ch *Changeset, field string, typ reflect.Type, par interface{}, fn ChangeFunc) bool {
	mpar, ok := par.(map[string]interface{})
	if !ok {
		return false
	}

	var innerch *Changeset

	if val, exist := ch.values[field]; exist && val != nil {
		innerch = fn(val, mpar)
	} else {
		innerch = fn(reflect.Zero(typ).Interface(), mpar)
	}

	ch.changes[field] = innerch

	// add errors to main errors
	mergeErrors(ch, innerch, field+".")

	return true
}

func castMany(ch *Changeset, field string, typ reflect.Type, params interface{}, fn ChangeFunc) bool {
	data := reflect.Zero(typ.Elem()).Interface()

	if spar, ok := params.([]map[string]interface{}); ok {
		chs := make([]*Changeset, 0, len(spar))

		for i, par := range spar {
			innerch := fn(data, par)
			chs = append(chs, innerch)

			// add errors to main errors
			mergeErrors(ch, innerch, field+"["+strconv.Itoa(i)+"].")
		}

		ch.changes[field] = chs
		return true
	} else if spar, ok := params.([]interface{}); ok {
		chs := make([]*Changeset, 0, len(spar))

		for i, par := range spar {
			p, ok := par.(map[string]interface{})
			if !ok {
				return false
			}

			innerch := fn(data, p)
			chs = append(chs, innerch)

			// add errors to main errors
			mergeErrors(ch, innerch, field+"["+strconv.Itoa(i)+"].")
		}

		ch.changes[field] = chs
		return true
	}

	return false
}

func mergeErrors(parent *Changeset, child *Changeset, prefix string) {
	for _, err := range child.errors {
		e := err.(errors.Error)
		AddError(parent, prefix+e.Field, e.Message)
	}
}
